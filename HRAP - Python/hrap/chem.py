# Author: Thomas A. Scott, https://www.scott-aero.com/

# HP Gibb's free energy minimization (specified input enthalpy and pressure)
# Note: RPA, CEA, PROPEP all use the same algorithm
# Why make this? Because pypropep is broken and abandoned, pycea requires uses to install Fortran, and Cantera's equilibrium solver has been broken for over a decade. That is, there are no suitable Python alternatives.

# Condensed species are mostly implemented but disabled as the procedure of solving for gas only before adding condensed to solve coupled proved necessary

# PORTING AND UNIT TESTS ARE WIP!



# Terminlogy explanations:
# Mixture - reaction products

# Unit explanations:
# s - specific entropy
# S - molar entropy
# h - specific enthalpy
# H - molar enthalpy
# g - Gibbs energy per kg of mixture
# mu_j - chemical potential per kmol of species j

# Extension explanations:
# _0 - fixed/initial value
# ^0 - standard state value
# _D - dimensionless value

# Working equations:
# s = sum n_j*S_j
# h = sum n_j*H_j
# g = sum n_j*mu_j

import numpy as np

from pathlib import Path
from dataclasses import dataclass
from typing import Dict



Rhat = 8314 # J/(K*kmol), universal gas constant

@partial(jax.tree_util.register_dataclass,
    data_fields=['T_min', 'T_max', 'dho', 'coeffs'],
    meta_fields=[])
@dataclass
class NASA9(object):
    T_min: float # K
    T_max: float # K
    # TODO: check consistent with curve
    dho: float # Formation enthalpy
    coeffs: jnp.array #list[float] # 9 coefficients
    
    # Nondimensionalized specific heat, Cp/Rhat
    def get_Cp_D(self, T):
        return self.coeffs[0]/(T*T) + self.coeffs[1]/T   + self.coeffs[2]      + \
               self.coeffs[3]*T     + self.coeffs[4]*T*T + self.coeffs[5]*T**3 + \
               self.coeffs[6]*T**4
    
    # Nondimensionalized specific enthalpy, H/(Rhat*T)
    def get_H_D(self, T):
         return -self.coeffs[0]/(T*T)    + self.coeffs[1]/T*np.log(T) + self.coeffs[2]          + \
                 self.coeffs[3]*T/2.0    + self.coeffs[4]*T*T/3.0     + self.coeffs[5]*T**3/4.0 + \
                 self.coeffs[6]*T**4/5.0 + self.coeffs[7]/T

    # Nondimensionalized specific entropy, S/Rhat
    def get_S_D(self, T):
        return -self.coeffs[0]/(2.0*T*T) - self.coeffs[1]/T       + self.coeffs[2]*np.log(T) + \
                self.coeffs[3]*T         + self.coeffs[4]*T*T/2.0 + self.coeffs[5]*T**3/3.0  + \
                self.coeffs[6]*T**4/4.0  + self.coeffs[8]

# @partial(jax.tree_util.register_dataclass,
#     data_fields=[],
#     meta_fields=[])
# @dataclass
# High-level thermodynamic information used during initialization
class ThermoSubstance(object):
    formula: str # Format should be similar to "(HCOOH)2-", all capitals
    comment: str # Such as data origin
    condensed: bool # Either condensed or gaseous
    is_product: bool # Always a reactant, not always a product
    composition: Dict[str, float] # two-letter code: relative moles i.e. chemical composition
    M: float # kg/kmol, molar mass
    providers: list[NASA9]
    T_min: float # Range where the substance is allowed to be used (may be a single point, may contain error margin past where it is defined)
    T_max: float

    def get_R(self): # J/(K*kg), specific gas constant
        return Rhat / self.M
    
    def get_prov(self, T):
        i = 0
        for j in range(1, len(self.providers)):
            if T > self.providers[j].T_min: i = j
        
        return self.providers[i]

    def get_Cp_D(self, T):
        return self.get_prov(T).get_Cp_D(T)
    
    def get_H_D(self, T):
        return self.get_prov(T).get_H_D(T)
        
    def get_S_D(self, T):
        return self.get_prov(T).get_S_D(T)

# Low-level compilable thermo substance used during evaluation (autogenerated from high-level counterpart)
# N_curve must be known statically to use JAX conditionals for piecewise fit
@partial(jax.tree_util.register_dataclass,
    data_fields=['T_min', 'T_max', 'dho', 'coeffs'],
    meta_fields=['N_curve'])
@dataclass
class InternalThermalSubstance(object):
    N_curve: int
    providers: list[NASA9]
    T_max: jnp.array
    
    # Get properties, using first or last if out of bounds
    def get_Cp_D(self, T):
        return jnp.select(T < T_max, [providers[i].get_Cp_D(T) for i in range(N_curve)], providers[-1].get_Cp_D(T))
    
    def get_H_D(self, T):
        return jnp.select(T < T_max, [providers[i].get_H_D(T) for i in range(N_curve)], providers[-1].get_H_D(T))
    
    def get_S_D(self, T):
        return jnp.select(T < T_max, [providers[i].get_S_D(T) for i in range(N_curve)], providers[-1].get_S_D(T))

def make_basic_reactant(formula: str, composition: dict, M: float, T0: float, h0: float, condensed = True) -> ThermoSubstance:
    """
    kg/kmol
    K
    J/mol
    """
    return ThermoSubstance(formula, '', condensed, False, { k.upper(): v for k, v in composition.items() }, M, [NASA9(0.9*T0, 1.1*T0, h0, [0.0]*2+[h0/Rhat/T0]+[0.0]*5)], 0.9*T0, 1.1*T0)

@dataclass
class ChemSolver:
    substances: Dict[str, ThermoSubstance]

    # TODO: remove std from comments
    
    # Takes in table such as thermo.ipa from RPA or thermo.dat from cpropep. Must be text, not binary
    # Must end with END REACTANTS and contain END PRODUCTS
    # Curve fit data should be dimensionless (Cp/R, S/R, and H/R) with S and H supplied at 1bar
    # Curve fit for Cp can not have more than 7 elements and exponents (-2, -1, 0, 1, 2, 3, 4) are always assumped, with data ignored
    def load_propep(self, chem_path):
        # Reads from entries such as:
        """
        name (18 char), comment (all remaining on line)
        H2O               Hf:Cox,1989. Woolley,1987. TRC(10/88) tuv25.                  
        temperature range entry count (2 char, kelvin), source identifier (8x char), elements (5x [2x char element, 6x char quantity]]), phase (2char, 0 for gas 1 for condensed), molecular weight (13 char, kg/kmol), heat of formation (15 char, J/mol, or enthalpy if entry count = 0 [single temperature, condensed])
         2 g 8/89 H   2.00O   1.00    0.00    0.00    0.00 0   18.0152800    -241826.000
        temperature interval (2x 11 char), ncoeffs (1 char), exponents (8x 5 char), H^O(298.15)-H^O(0) (17 char, ?)
            200.000   1000.0007 -2.0 -1.0  0.0  1.0  2.0  3.0  4.0  0.0         9904.092
        coefficients (across 2 lines, up to 8x 16 char, may be blank to imply skip for formatting)
        -3.947960830D+04 5.755731020D+02 9.317826530D-01 7.222712860D-03-7.342557370D-06
         4.955043490D-09-1.336933246D-12                -3.303974310D+04 1.724205775D+01
        (repeated for other temperature intervals)
           1000.000   6000.0007 -2.0 -1.0  0.0  1.0  2.0  3.0  4.0  0.0         9904.092
         1.034972096D+06-2.412698562D+03 4.646110780D+00 2.291998307D-03-6.836830480D-07
         9.426468930D-11-4.822380530D-15                -1.384286509D+04-7.978148510D+00
        """
        with open(chem_path, 'r') as chem_file:
            substances = { }
            strip = ' '
            mode, in_reactants = 0, False
            def readline(chem_file):
                line = chem_file.readline().rstrip('\n')
                while len(line.strip(strip)) == 0 or line[0] == '!': # Skip comments and blank lines
                    line = chem_file.readline().rstrip('\n')
                return line
            line = readline(chem_file)
            while line:
                if line.startswith('thermo'):
                    chem_file.readline() # Skip line containing extraneous range data
                elif line.startswith('END PRODUCTS'):
                    in_reactants = True
                elif line.startswith('END REACTANTS'):
                    break # End of file
                else: # Chem entry
                    i = 0
                    
                    formula = line[i:i+18].strip(strip); i += 18
                    comment = ''
                    if len(line) > 18:
                        comment = line[i:].strip(strip)
                    
                    line = readline(chem_file); i = 0
                    fitPieces = int(line[i:i+2].strip(strip)); i += 2
                    i += 8 # Ignore source identifier
                    composition = { }
                    for j in range(5):
                        symbol = line[i:i+2].strip(strip).upper(); i += 2
                        quantity = float(line[i:i+6].strip(strip)); i += 6
                        if len(symbol) == 0:
                            continue
                        composition[symbol] = quantity
                    phase = int(line[i:i+2].strip(strip)); i += 2
                    condensed = phase != 0 # TODO: store phase?
                    M = float(line[i:i+13].strip(strip)); i += 13
                    # Comes as kJ/kmol so convert to J/kmol
                    DeltaHForm = 1000 * float(line[i:i+15].strip(strip))

                    line = readline(chem_file); i = 0
                    providers = []
                    if fitPieces == 0: # If single temp (only appropriate for condensed reactants)
                        if not in_reactants:
                            print(f'ERROR: Zero piece data is not permitted for product, {formula}, as entropy is needed to solve!')
                        
                        T = float(line[i:i+11].strip(strip))
                        # Valid at a single temperature but is specified as constant Cp
                        providers.append(NASA9(0.9*T, 1.1*T, DeltaHForm, [0.0]*2+[DeltaHForm/Rhat/T]+[0.0]*5))
                    else:
                        for j in range(fitPieces):
                            i = 0
                            T_min = float(line[i:i+11].strip(strip)); i += 11
                            T_max = float(line[i:i+11].strip(strip)); i += 11
                            ncoffs = int(line[i:i+1].strip(strip)); i += 1
                            if ncoffs > 8:
                                print(f'Fatal error: Thermochemical substance {formula} cannot have more than 8 coefficients (not counting the 9th entropy constant)!')
                                return
                            # TODO: warning if <8?
                            i += 8*5 # Ignore exponents (only specified for C_p and have to make consistent assumptions for others)
                            dho = float(line[i:i+17].strip(strip))

                            coeffs, m = [0.0]*9, 0
                            line = readline(chem_file); i = 0
                            for k in range(5):
                                coeff = line[i:i+16].strip(strip); i += 16
                                if len(coeff) == 0: continue
                                coeffs[m] = float(coeff.replace('D', 'E')); m += 1
                            
                            line = readline(chem_file); i = 0
                            for k in range(2):
                                coeff = line[i:i+16].strip(strip); i += 16
                                if len(coeff) == 0: continue
                                coeffs[m] = float(coeff.replace('D', 'E')); m += 1
                            i += 16 # center is always ignored
                            # Last two are for dimensionless molar enthalpy and entropy, respectively
                            for k in range(2):
                                coeff = line[i:i+16].strip(strip); i += 16
                                if len(coeff) == 0: continue
                                coeffs[7+k] = float(coeff.replace('D', 'E'))
                            providers.append(NASA9(T_min, T_max, DeltaHForm, coeffs))
                            # formula: str # Format should be similar to "(HCOOH)2-", all capitals
                            if j != fitPieces-1: line = readline(chem_file)
                    T_min, T_max = np.min([prov.T_min for prov in providers]), np.max([prov.T_max for prov in providers])
                    substances[formula] = ThermoSubstance(formula, comment, condensed, not in_reactants, composition, M, providers, T_min, T_max)
                
                line = readline(chem_file)
        return substances
    
    def __init__(self, chem_infos):
        self.substances = { }
        if not (isinstance(chem_infos, list) or isinstance(chem_infos, tuple)):
            chem_infos = [chem_infos]
        for chem_info in chem_infos:
            # TODO: check for duplicates!
            if isinstance(chem_info, str) or isinstance(chem_info, Path):
                new_substances = self.load_propep(chem_info)
                for k, v in new_substances.items():
                    if k in self.substances:
                        print('Warning chemical "{k}" was defined several times, only first occurance used'.format(k=k))
                    else:
                        self.substances[k] = v
            elif isinstance(chem_info, ThermoSubstance):
                if chem_info.formula in self.substances:
                    print('Warning chemical "{k}" was defined several times, only first occurance used'.format(k=chem_info.formula))
                else:
                    self.substances[chem_info.formula] = chem_info
            else:
                print('Error: invalid chem info type', type(chem_info))

    @partial(jax.tree_util.register_dataclass,
        data_fields=['present_elements', 'N_elem', 'N_gas', 'gasses', 'gas_a'],
        meta_fields=[])
    @dataclass
    class InternalMeta(object):
        present_elements: list[str]
        N_elem: int
        N_gas: int

        # TODO: sub should only check formula as we use .index here - not anymore
        gasses: list[ThermoSubstance] # N_subs
        gas_a: jnp.ndarray # (N_gas, N_elem) amount of the element in each substance
    
    @partial(jax.tree_util.register_dataclass,
        data_fields=['P', 'h_0', 'n', 'T', 'Deltaln_n', 'Deltaln_T', 'b_i0', 'b_i0_max', 'pi_i', 'n_j', 'Deltan_j', 'gas_Cp_D', 'gas_H_D', 'gas_S_D'],
        meta_fields=[])
    @dataclass
    class InternalState(object):
        P: float # Pa, constant pressure
        h_0: float # input enthalpy
        n: float # kmol/kg, inverse molar mass of mixture
        T: float # K, current temperature
        Deltaln_n: float
        Deltaln_T: float

        # cond_subs: np.ndarray
        b_i0: jnp.ndarray # (N_elem), used to keep the elemental mass density balance identical to the inputs
        b_i0_max: float
        pi_i: jnp.ndarray # (N_elem)
        n_j: jnp.ndarray # (N_gas), kmol of species j per kg of mixture
        Deltan_j: jnp.ndarray # (N_gas)

        # TODO: sub should only check formula as we use .index here - not anymore
        gas_Cp_D: np.ndarray # Current substance properties
        gas_H_D: np.ndarray
        gas_S_D: np.ndarray

    def ReducedEQ0k(b_k0, a_kj_n_J, x, xm):
        # a_kj_n_J is each a_kj*n_j, j in 1...N_gas
        result = -b_k0
        result += jnp.sum((a_kj_n_J[:,None] * xm.gas_a) * x.pi_i[None,:]) # Sum across all elements in the substance, a_kj*a_ij*n_j*pi_i, arrays broadcast along each gas
        result += jnp.sum(a_kj_n_J*x.Deltaln_n) # a_kj*n_j*Deltaln_n
        result += jnp.sum(a_kj_n_J*x.gas_H_D*x.Deltaln_T) # a_kj*n_j*H_j/(R*T)*Deltaln_T
        result -= jnp.sum(a_kj_n_J*(x.gas_H_D-x.gas_S_D+jnp.log(x.n_j/x.n)+jnp.log(x.P/1.0E5))) # a_kj*n_j*mu_j/(R*T)
        result += jnp.sum(a_kj_n_J) # b_k contribution, a_kj*n_j
        return result
    
    def solve(self, Pc, supply, max_iters=200, internal_state=None, reinit=True):
        # Basic input checks
        if len(supply) == 0 or Pc <= 0.0:
            return Result(False), None
        
        # Electrons always included so that ions are possible to form
        present_elements = ['E']
        for formula, inputs in supply.items():
            substance = self.substances[formula]
            for elem, amount in substance.composition.items():
                if not elem in present_elements:
                    present_elements.append(elem)
        # present_elements = sorted(present_elements) # TODO

        x, xm = internal_state
        if xm != None: # Check that provided internal_state is usable
            if present_elements != xm.present_elements:
                print('Warning: provided internal state is not usable due to differing elemental composition, rebuilding...')
                xm = None
        if xm == None:
            x, xm = self.InternalState(), self.InternalState()
            x.N_elem = len(present_elements)
            # x.gas_prod_I, x.gas_prod_a, x.cond_prod_I, x.cond_prod_a = [[[] for i in range(x.N_elem)] for i in range(4)]
            
            xm.gasses = []
            for sub in self.substances.values():
                if sub.is_product:
                    # TODO: temp cutoff too like SSTS?
                    if not sub.condensed and all([elem in present_elements for elem in sub.composition]):
                        # print('RELEVANT GAS', sub.formula, sub.condensed)
                        xm.gasses.append(sub)
            xm.N_gas = len(xm.gasses)

            xm.gas_a = np.zeros((xm.N_gas, xm.N_elem))
            for i, gas in enumerate(xm.gasses):
                for elem, amount in sub.composition.items():
                    j = present_elements.index(elem)
                    xm.gas_a[i, j] = amount
            xm.gas_a = jnp.array(xm.gas_a)
            
            reinit = True

        if reinit:
            x.T = 3000 # K, current temperature
            x.n = 0.1 # total kmol/kg
            x.n_j = jnp.ones(xm.N_gas) * 0.1 / xm.N_gas
            x.pi_i = jnp.zeros(xm.N_elem)
            x.Deltaln_n = 0.0
            x.Deltaln_T = 0.0
            x.Deltan_j = jnp.zeros(xm.N_gas)
            x.b_i0 = jnp.zeros(xm.N_elem)
        
        # Begin from supply
        x.P = Pc
        x.h_0 = 0.0
        # print('all x subs', x.subs)
        for formula, inputs in supply.items():
            sub = self.substances[formula]
            m_frac, T, P = inputs
            # j = x.subs.index(sub)
            n_j = m_frac/sub.M
            x.h_0 += n_j * sub.get_H_D(T) * Rhat * T
            for elem, amount in sub.composition.items():
                x.b_i0[present_elements.index(elem)] += amount * n_j # Loop across elements
        x.b_i0_max = np.max(x.b_i0)

        N_dof = x.N_elem + 2
        iter = 1
        while iter <= max_iters:
            # Update properties
            for i in range(x.N_sub):
                prov = x.subs[i].get_prov(x.T) # Piecewise NASA9 instance
                x.gas_Cp_D[i], x.gas_H_D[i], x.gas_S_D[i] = prov.get_Cp_D(x.T), prov.get_H_D(x.T), prov.get_S_D(x.T)
            
            rhs = np.zeros(N_dof)
            rhs[:xm.N_elem] = jax.vmap(ReducedEQ0k, (0, 1, None, None))(x.b_i0, xm.gas_a * x.n_j[:,None], x, xm)
            # rhs[-2] = self.ReducedEQ2(x)
            # rhs[-1] = self.ReducedEQ3(x)
            print('func evals', rhs[:x.N_elem], rhs[-2:])
            exit()
        
