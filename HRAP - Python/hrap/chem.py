# Author: Thomas A. Scott, https://www.scott-aero.com/

# HP Gibb's free energy minimization (specified input enthalpy and pressure)
# Note: RPA, CEA, PROPEP all use the same algorithm
# Why make this? Because pypropep is broken and abandoned, pycea requires uses to install Fortran, and Cantera's equilibrium solver has been broken for over a decade. That is, there are no suitable Python alternatives.

# Condensed species are mostly implemented but disabled as the procedure of solving for gas only before adding condensed to solve coupled proved necessary

# PORTING AND UNIT TESTS ARE WIP!



# Terminlogy explanations:
# Mixture - reaction products

# Unit explanations:
# s - specific entropy
# S - molar entropy
# h - specific enthalpy
# H - molar enthalpy
# g - Gibbs energy per kg of mixture
# mu_j - chemical potential per kmol of species j

# Extension explanations:
# _0 - fixed/initial value
# ^0 - standard state value
# _D - dimensionless value

# Working equations:
# s = sum n_j*S_j
# h = sum n_j*H_j
# g = sum n_j*mu_j

import numpy as np

from pathlib import Path
from dataclasses import dataclass
from typing import Dict



Rhat = 8314 # J/(K*kmol), universal gas constant

@partial(jax.tree_util.register_dataclass,
    data_fields=['T_min', 'T_max', 'dho', 'coeffs'],
    meta_fields=[])
@dataclass
class NASA9(object):
    T_min: float # K
    T_max: float # K
    # TODO: check consistent with curve
    dho: float # Formation enthalpy
    coeffs: jnp.array #list[float] # 9 coefficients
    
    # Nondimensionalized specific heat, Cp/Rhat
    def get_Cp_D(self, T):
        return self.coeffs[0]/(T*T) + self.coeffs[1]/T   + self.coeffs[2]      + \
               self.coeffs[3]*T     + self.coeffs[4]*T*T + self.coeffs[5]*T**3 + \
               self.coeffs[6]*T**4
    
    # Nondimensionalized specific enthalpy, H/(Rhat*T)
    def get_H_D(self, T):
         return -self.coeffs[0]/(T*T)    + self.coeffs[1]/T*np.log(T) + self.coeffs[2]          + \
                 self.coeffs[3]*T/2.0    + self.coeffs[4]*T*T/3.0     + self.coeffs[5]*T**3/4.0 + \
                 self.coeffs[6]*T**4/5.0 + self.coeffs[7]/T

    # Nondimensionalized specific entropy, S/Rhat
    def get_S_D(self, T):
        return -self.coeffs[0]/(2.0*T*T) - self.coeffs[1]/T       + self.coeffs[2]*np.log(T) + \
                self.coeffs[3]*T         + self.coeffs[4]*T*T/2.0 + self.coeffs[5]*T**3/3.0  + \
                self.coeffs[6]*T**4/4.0  + self.coeffs[8]

# @partial(jax.tree_util.register_dataclass,
#     data_fields=[],
#     meta_fields=[])
# @dataclass
# High-level thermodynamic information used during initialization
class ThermoSubstance(object):
    formula: str # Format should be similar to "(HCOOH)2-", all capitals
    comment: str # Such as data origin
    condensed: bool # Either condensed or gaseous
    is_product: bool # Always a reactant, not always a product
    composition: Dict[str, float] # two-letter code: relative moles i.e. chemical composition
    M: float # kg/kmol, molar mass
    providers: list[NASA9]
    T_min: float # Range where the substance is allowed to be used (may be a single point, may contain error margin past where it is defined)
    T_max: float

    def get_R(self): # J/(K*kg), specific gas constant
        return Rhat / self.M
    
    def get_prov(self, T):
        i = 0
        for j in range(1, len(self.providers)):
            if T > self.providers[j].T_min: i = j
        
        return self.providers[i]

    def get_Cp_D(self, T):
        return self.get_prov(T).get_Cp_D(T)
    
    def get_H_D(self, T):
        return self.get_prov(T).get_H_D(T)
        
    def get_S_D(self, T):
        return self.get_prov(T).get_S_D(T)

# Low-level compilable thermo substance used during evaluation (autogenerated from high-level counterpart)
class InternalThermalSubstance(object)
    
